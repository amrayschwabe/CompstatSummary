\section{Bootstrap}
$\hat{\theta} \cong$ Var. Estimate on original data, $\hat{\theta}^\star \cong$ Estimate on bootstraped data, $R \cong$ \# of bootstrap samples
\textbf{Bootstrap consistency: }$P(a_n(\hat\Theta_n-\Theta) \leq x)-P^*(a_n(\hat\Theta_n^*-\hat\Theta_n \leq x) \rightarrow^p 0$ as $n \rightarrow \inf$ implication of that: for large n, we have that distribution of $a_n(\hat\Theta_n - \Theta_n)$ is like $a_n(\hat\Theta^*_n- \hat\Theta_n)$
\textbf{quantile}: $[q_{\hat\theta_n^*}(\frac{\alpha}{2}),q_{\hat\theta_n^*}(1-\frac{\alpha}{2})]$
\textbf{Normal: }$\hat\Theta_n \frac{+}{} q_Z(1-\frac{\alpha}{2}\hat{sd}(\hat\Theta_n)$, where $Z \textasciitilde N(0,1), \hat{sd}(\hat \Theta_n) = \sqrt{\hat{Var}^*(\hat{\Theta}_n^*}$ this one is intuitive but "wrong way around"
\textbf{reversed quantile: } $[\hat\Theta_n - q_{\hat\Theta_n^*-\hat\Theta_n}(1-\frac{\alpha}{2}), \hat\Theta_n - q_{\hat\Theta_n^*-\hat\Theta_n}(\frac{\alpha}{2})]$  if distribution of $\hat \Theta_n^*- \hat \Theta_n$ is symmetrical around zero, then the quantile bootstrap confidence interval and the reversed quantile confidence interval are identical 
\textbf{Bootstrap CI: }$[\hat\Theta_n - q_{\frac{\hat\Theta_n^*-\hat\Theta_n}{\hat{sd}(\hat\Theta_n^*}}(1-\frac{\alpha}{2})\hat{sd}(\hat\Theta_n), \hat\Theta_n - q_{\frac{\hat\Theta_n^*-\hat\Theta_n}{\hat{sd}(\hat\Theta_n^*}}(\frac{\alpha}{2})\hat{sd}(\hat\Theta_n)]$ where $\hat{sd}(\hat\Theta_n)$ is as above and $\hat{sd}(\hat\Theta_n^*)$ are computed by second layer bootstrap samples. This has best theoretical properties, but computationally intensive. 
\textbf{Parametric bootstrap: } We assume that our data is generated by some distribution and only assume the parameters of this distribution. This is good if parametric model is approximately correct, but bad if not. 
\textbf{Smoothed bootstrap: } We estimate our distribution by some smooth non-parametric estimate $\tilde P_n$. Is inbetween parametric and non-parametric, is good if underlying distribution really is smooth. 
\textbf{Following code: For 75 percentile of datapoints assuming gamma function, R = 1000, len.b <- length(datapoints)}
\textbf{Param. bootstrap by hand:}
\begin{lstlisting}[language=R]
res <- rep(NA, R)
for (i in 1:R) {
  x <- rgamma(n = len.b, shape = fit.gamma\$estimate["shape"],
              rate = fit.gamma\$estimate["rate"])
  res[i] <- quantile(x, probs = 0.75)}}
\end{lstlisting}
\textbf{Non-param Bootstrap by hand:}
\begin{lstlisting}[language=R]
res2 <- rep(NA, R)
for (i in 1:R) {
  ind <- sample(1:len.b, len.b, replace = TRUE)
  res2[i] <- quantile(boogg[ind], probs = 0.75)}
\end{lstlisting}

\textbf{Non-param. Bootstrap with library: } 
\begin{lstlisting}[language=R]
boot.fn=function(data,index){
  return(coef(lm(y~x,data=data,subset=index)))}
boot.fit <- boot(datapoints, statistic=boot.fn, R=5000)
boot.fit$t0 #estimate on original data
boot.fit$t  #estimates on bootstrap samples
boot.ci(boot.fit, index=c(1), type="basic") # CI
\end{lstlisting}
\textbf{Param. Bootstrap with library:} 
\begin{lstlisting}[language=R]
fun.theta <- function(x, ind) {quantile(x[ind], probs = 0.75)}
fun.gen <- function(x, mle) {
  rgamma(length(x), shape = mle[1], rate = mle[2])}
boot.res <- boot(datapoints, fun.theta, R = R, sim = "parametric", ran.gen = fun.gen, mle = fit.gamma\$estimate)
\end{lstlisting}
\textbf{Bootstrap CI by hand:}
\begin{lstlisting}[language=R]
quantile.CI <- quantile(theta.star, probs = c(0.025, 0.975))
normal.CI <- c(theta.hat - qnorm(0.975) * sd(theta.star), theta.hat + qnorm(0.975) * sd(theta.star))
reversed.CI <- theta.hat - quantile(theta.star - theta.hat, probs = c(0.975, 0.025))
\end{lstlisting}